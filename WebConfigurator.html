
<html>
		<head>
			<title>--- Web Product Configurator ---</title>
			<style>
			body {
				font-family: Monospace;
				background-color:#f0f0f0;
				margin: 0px;
				overflow: hidden;
			}
			canvas {
				width: 100%;
				height: 100%;
			}
		</style>
			<script src="libs/three.js"></script>
			<script src="libs/stats.min.js"></script>
			<script src="libs/OBJLoader.js"></script>
			<script src="libs/Coordinates.js"></script>
            <script src="libs/OrbitControls.js"></script>
			<script src="libs/GLTFLoader.js"></script>
			<script src='libs/dat.gui.min.js'></script>
			<script src='libs/BufferGeometryUtils.js'></script>

		</head>
		-------------- Andrea Mansi UNIUD --- Progetto Interactive 3D Graphics --- Web Product Configurator ---
			
			<script type="text/x-glsl" id="GlossyVertex">
				precision highp float;
				precision highp int;
				attribute vec4 tangent;
				varying vec3 vNormal;
				varying vec3 vTangent;
				varying vec3 vBitangent;
				varying vec3 vPosition;
				varying vec2 vUv;
		
				void main() {
					vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
					vPosition = vPos.xyz;
					vNormal = normalize(normalMatrix * normal);
					vec3 objectTangent = vec3( tangent.xyz );
					vec3 transformedTangent = normalMatrix * objectTangent;
					vTangent = normalize( transformedTangent );
					vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
					vUv = uv;
					gl_Position = projectionMatrix * vPos;
				}
			</script>
		
			<script type="text/x-glsl" id="GlossyFragment">
				precision highp float;
				precision highp int;
				varying vec3 vNormal;
				varying vec3 vTangent;
				varying vec3 vBitangent;
				varying vec3 vPosition;
				varying vec2 vUv;
				uniform vec3 cspec;
				uniform sampler2D normalMap;
				uniform samplerCube envMap;
				uniform vec2 normalScale;
				uniform float roughness;
	
				const float PI = 3.14159;
				#define saturate(a) clamp( a, 0.0, 1.0 )
	
				float pow2( const in float x ) { return x*x; }
	
				float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {
					 float maxMIPLevelScalar = float( maxMIPLevel );
					 float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );
					 return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
				 }
	
				float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
					  return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
				  }
	
				// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations
				vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
					return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
				}
	
				vec3 BRDF_Specular_GGX_Environment( vec3 normal, vec3 viewDir, const in vec3 cspec, const in float roughness ) {
	
					float dotNV = saturate( dot( normal, viewDir ) );
					const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
					const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
					vec4 r = roughness * c0 + c1;
					float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
					vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;
					return cspec * AB.x + AB.y;
	
				}
	
				void main() {
					vec3 normal = normalize( vNormal);
					vec3 tangent = normalize( vTangent);
					vec3 bitangent = normalize( vBitangent );
					mat3 vTBN = mat3( tangent, bitangent, normal);
					vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
					mapN.xy = normalScale * mapN.xy;
					vec3 n = normalize( vTBN * mapN );
					vec3 v = normalize( -vPosition);
					vec3 vReflect = reflect(vPosition,n);
					vec3 r = inverseTransformDirection( vReflect, viewMatrix );
	
					float blinnShininessExponent = GGXRoughnessToBlinnExponent(roughness);
					float specularMIPLevel = getSpecularMIPLevel(blinnShininessExponent, 8);
	
					 vec3 envLight = textureCubeLodEXT( envMap, vec3(-r.x, r.yz), specularMIPLevel ).rgb;
					 // texture in sRGB, linearize
					envLight = pow( envLight, vec3(2.2));
					vec3 outRadiance = envLight*BRDF_Specular_GGX_Environment(n, v, cspec, roughness);
					// gamma encode the final value
					gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
					//gl_FragColor = vec4(r,1.0);
				}
			</script>

			<script type="text/x-glsl" id="LamebrtianGlossyFragment">
				precision highp float;
				precision highp int;
				varying vec3 vNormal;
				varying vec3 vTangent;
				varying vec3 vBitangent;
				varying vec3 vPosition;
				varying vec2 vUv;
				uniform vec3 cspec;
				uniform sampler2D normalMap;
				uniform samplerCube envMap;
				uniform vec2 normalScale;
				uniform float roughness;

				//Lambertian Stuff
				uniform vec3 pointLightPosition1; // in world space
				uniform vec3 clight1;
				uniform vec3 pointLightPosition2; // in world space
				uniform vec3 clight2;
				uniform vec3 pointLightPosition3; // in world space
				uniform vec3 clight3;
				uniform vec3 cdiff;
	
				const float PI = 3.14159;

				//Schlick microfacet BRDF
				vec3 FSchlick(float lDoth) {
					return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
				}
			
				//NDF -> Normal distribution function GGX Approx
				float DGGX(float nDoth, float alpha) {
					float alpha2 = alpha*alpha;
					float d = nDoth*nDoth*(alpha2-1.0)+1.0;
					return (  alpha2 / (PI*d*d));
				}
			
				//Geometry Factor
				float G1(float dotProduct, float k) {
					return (dotProduct / (dotProduct*(1.0-k) + k) );
				}
			
				float GSmith(float nDotv, float nDotl) {
						float k = roughness*roughness;
						return G1(nDotl,k)*G1(nDotv,k);
				}

				#define saturate(a) clamp( a, 0.0, 1.0 )
	
				float pow2( const in float x ) { return x*x; }
	
				float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {
					 float maxMIPLevelScalar = float( maxMIPLevel );
					 float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );
					 return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
				 }
	
				float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
					  return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
				  }
	
				// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations
				vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
					return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
				}
	
				vec3 BRDF_Specular_GGX_Environment( vec3 normal, vec3 viewDir, const in vec3 cspec, const in float roughness ) {
	
					float dotNV = saturate( dot( normal, viewDir ) );
					const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
					const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
					vec4 r = roughness * c0 + c1;
					float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
					vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;
					return cspec * AB.x + AB.y;
	
				}
	
				void main() {

					//GLOSSY PHASE
					vec3 normal = normalize( vNormal);
					vec3 tangent = normalize( vTangent);
					vec3 bitangent = normalize( vBitangent );
					mat3 vTBN = mat3( tangent, bitangent, normal);
					vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
					mapN.xy = normalScale * mapN.xy;
					vec3 n = normalize( vTBN * mapN );
					vec3 v = normalize( -vPosition);
					vec3 vReflect = reflect(vPosition,n);
					vec3 r = inverseTransformDirection( vReflect, viewMatrix );
	
					float blinnShininessExponent = GGXRoughnessToBlinnExponent(roughness);
					float specularMIPLevel = getSpecularMIPLevel(blinnShininessExponent, 8);
	
					 vec3 envLight = textureCubeLodEXT( envMap, vec3(-r.x, r.yz), specularMIPLevel ).rgb;
					 // texture in sRGB, linearize
					envLight = pow( envLight, vec3(2.2));
					 // vec3 outRadiance = envLight*BRDF_Specular_GGX_Environment(n, v, cspec, roughness);
					
					//LAMBERTIAN PHASE
					
					vec4 plPos1 = viewMatrix * vec4( pointLightPosition1, 1.0 );
					vec4 plPos2 = viewMatrix * vec4( pointLightPosition2, 1.0 );
					vec4 plPos3 = viewMatrix * vec4( pointLightPosition3, 1.0 );

					vec3 l1 = normalize(plPos1.xyz - vPosition.xyz);
					vec3 l2 = normalize(plPos2.xyz - vPosition.xyz);
					vec3 l3 = normalize(plPos3.xyz - vPosition.xyz);
					
					vec3 n1 = normalize( vNormal );  // interpolation destroys normalization, so we have to normalize
					vec3 n2 = normalize( vNormal );
					vec3 n3 = normalize( vNormal );  
					
					vec3 v1 = normalize(-vPosition);
					vec3 v2 = normalize(-vPosition);
					vec3 v3 = normalize(-vPosition);
					
					mat3 h;
					h[0] = normalize( v1 + l1);
					h[1] = normalize( v2 + l2);
					h[2] = normalize( v3 + l3);
					
					// small quantity to prevent divisions by 0
					float nDotl[3];
					nDotl[0] = max(dot( n1, l1 ),0.000001);
					nDotl[1] = max(dot( n2, l2 ),0.000001);
					nDotl[2] = max(dot( n3, l3 ),0.000001);
					
					float lDoth[3];
					lDoth[0] = max(dot( l1, h[0] ),0.000001);
					lDoth[1] = max(dot( l2, h[1] ),0.000001);
					lDoth[2] = max(dot( l3, h[2] ),0.000001);
					
					float nDoth[3];
					nDoth[0] = max(dot( n1, h[0] ),0.000001);
					nDoth[1] = max(dot( n2, h[1] ),0.000001);
					nDoth[2] = max(dot( n3, h[2] ),0.000001);

					float vDoth[3];
					vDoth[0] = max(dot( v1, h[0] ),0.000001);
					vDoth[1] = max(dot( v2, h[1] ),0.000001);
					vDoth[2] = max(dot( v3, h[2] ),0.000001);
					
					float nDotv[3];
					nDotv[0] = max(dot( n1, v1 ),0.000001);
					nDotv[1] = max(dot( n2, v2 ),0.000001);
					nDotv[2] = max(dot( n3, v3 ),0.000001);
					
					vec3 fresnel1 = FSchlick(lDoth[0]);
					vec3 fresnel2 = FSchlick(lDoth[1]);
					vec3 fresnel3 = FSchlick(lDoth[2]);
					
					vec3 BRDF1 = (vec3(1.0)-fresnel1)*cdiff/PI + fresnel1*GSmith(nDotv[0],nDotl[0])*DGGX(nDoth[0],roughness*roughness)/
						(4.0*nDotl[0]*nDotv[0]);
					vec3 BRDF2 = (vec3(1.0)-fresnel2)*cdiff/PI + fresnel2*GSmith(nDotv[1],nDotl[1])*DGGX(nDoth[1],roughness*roughness)/
						(4.0*nDotl[1]*nDotv[1]);
					vec3 BRDF3 = (vec3(1.0)-fresnel3)*cdiff/PI + fresnel3*GSmith(nDotv[2],nDotl[2])*DGGX(nDoth[2],roughness*roughness)/
						(4.0*nDotl[2]*nDotv[2]);

					//vec3 outRadiance = envLight*BRDF_Specular_GGX_Environment(n, v, cspec, roughness);
					//vec3 outRadiance = (PI* (clight1 * nDotl[0]) * BRDF1) + (PI* (clight2 * nDotl[1]) * BRDF2)+ (PI* (clight3 * nDotl[2]) * BRDF3);
					
					vec3 outRadiance = envLight*BRDF_Specular_GGX_Environment(n, v, cspec, roughness) + (PI* (clight1 * nDotl[0]) * BRDF1) + (PI* (clight2 * nDotl[1]) * BRDF2)+ (PI* (clight3 * nDotl[2]) * BRDF3);
					

					// gamma encode the final value
					gl_FragColor = vec4(pow((outRadiance), vec3(1.0/1.0)), 1.0);


				}
			</script>

			<script type="text/x-glsl" id="vertexBRDF_Lambertian_Microfacet">
				varying vec3 vNormal;
				varying vec3 vPosition;
			
				void main() {
					vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
					vPosition = vPos.xyz;
					vNormal = normalMatrix * normal;
					gl_Position = projectionMatrix * vPos;
				}
			</script>

			<script type="text/x-glsl" id="fragmentBRDF_Lambertian_Microfacet">
					varying vec3 vNormal;
					varying vec3 vPosition;
				
					//uniform mat3 pointLightsPositions;
					//uniform mat3 clight;
				
					uniform vec3 pointLightPosition1; // in world space
					uniform vec3 clight1;
					uniform vec3 pointLightPosition2; // in world space
					uniform vec3 clight2;
					uniform vec3 pointLightPosition3; // in world space
					uniform vec3 clight3;
				
					uniform vec3 cspec;
					uniform vec3 cdiff;
					uniform float roughness;
					const float PI = 3.14159;
				
					//Schlick microfacet BRDF
					vec3 FSchlick(float lDoth) {
						return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
					}
				
					//NDF -> Normal distribution function GGX Approx
					float DGGX(float nDoth, float alpha) {
						float alpha2 = alpha*alpha;
						float d = nDoth*nDoth*(alpha2-1.0)+1.0;
						return (  alpha2 / (PI*d*d));
					}
				
					//Geometry Factor
					float G1(float dotProduct, float k) {
						return (dotProduct / (dotProduct*(1.0-k) + k) );
					}
				
					float GSmith(float nDotv, float nDotl) {
							float k = roughness*roughness;
							return G1(nDotl,k)*G1(nDotv,k);
					}
				
					void main() {
					
						
						vec4 plPos1 = viewMatrix * vec4( pointLightPosition1, 1.0 );
						vec4 plPos2 = viewMatrix * vec4( pointLightPosition2, 1.0 );
						vec4 plPos3 = viewMatrix * vec4( pointLightPosition3, 1.0 );

						vec3 l1 = normalize(plPos1.xyz - vPosition.xyz);
						vec3 l2 = normalize(plPos2.xyz - vPosition.xyz);
						vec3 l3 = normalize(plPos3.xyz - vPosition.xyz);
					
						vec3 n1 = normalize( vNormal );  // interpolation destroys normalization, so we have to normalize
						vec3 n2 = normalize( vNormal );
						vec3 n3 = normalize( vNormal );  
					
						vec3 v1 = normalize(-vPosition);
						vec3 v2 = normalize(-vPosition);
						vec3 v3 = normalize(-vPosition);
					
						mat3 h;
						h[0] = normalize( v1 + l1);
						h[1] = normalize( v2 + l2);
						h[2] = normalize( v3 + l3);
					
						// small quantity to prevent divisions by 0
						float nDotl[3];
						nDotl[0] = max(dot( n1, l1 ),0.000001);
						nDotl[1] = max(dot( n2, l2 ),0.000001);
						nDotl[2] = max(dot( n3, l3 ),0.000001);
					
						float lDoth[3];
						lDoth[0] = max(dot( l1, h[0] ),0.000001);
						lDoth[1] = max(dot( l2, h[1] ),0.000001);
						lDoth[2] = max(dot( l3, h[2] ),0.000001);
					
						float nDoth[3];
						nDoth[0] = max(dot( n1, h[0] ),0.000001);
						nDoth[1] = max(dot( n2, h[1] ),0.000001);
						nDoth[2] = max(dot( n3, h[2] ),0.000001);

						float vDoth[3];
						vDoth[0] = max(dot( v1, h[0] ),0.000001);
						vDoth[1] = max(dot( v2, h[1] ),0.000001);
						vDoth[2] = max(dot( v3, h[2] ),0.000001);
					
						float nDotv[3];
						nDotv[0] = max(dot( n1, v1 ),0.000001);
						nDotv[1] = max(dot( n2, v2 ),0.000001);
						nDotv[2] = max(dot( n3, v3 ),0.000001);
					
						vec3 fresnel1 = FSchlick(lDoth[0]);
						vec3 fresnel2 = FSchlick(lDoth[1]);
						vec3 fresnel3 = FSchlick(lDoth[2]);
					
						vec3 BRDF1 = (vec3(1.0)-fresnel1)*cdiff/PI + fresnel1*GSmith(nDotv[0],nDotl[0])*DGGX(nDoth[0],roughness*roughness)/
							(4.0*nDotl[0]*nDotv[0]);

						vec3 BRDF2 = (vec3(1.0)-fresnel2)*cdiff/PI + fresnel2*GSmith(nDotv[1],nDotl[1])*DGGX(nDoth[1],roughness*roughness)/
							(4.0*nDotl[1]*nDotv[1]);

						vec3 BRDF3 = (vec3(1.0)-fresnel3)*cdiff/PI + fresnel3*GSmith(nDotv[2],nDotl[2])*DGGX(nDoth[2],roughness*roughness)/
							(4.0*nDotl[2]*nDotv[2]);
					
						vec3 outRadiance = (PI* (clight1 * nDotl[0]) * BRDF1) + (PI* (clight2 * nDotl[1]) * BRDF2) + (PI* (clight3 * nDotl[2]) * BRDF3);

						// gamma encode the final value
						gl_FragColor = vec4(pow( outRadiance, vec3(1.0/1.0)), 1.0); //2.2 or 1? wtf
					}
			</script>

            <script type="text/x-glsl" id="BasicVertexShader">
                varying vec3 color;
				
				void main() {
					vec3 newPosition = position;
					// transforms the vertex from object space to clip space coords		
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
                }
			</script>
		
			<script type="text/x-glsl" id="BasicColorFragmentShader">
				varying vec3 color;
				void main() {
					gl_FragColor = vec4(0.5,0.5,0.5,1.0);
				}
            </script>
	
			<script>
				// Main Variables
				var scene, camera, renderer, camera, stats;
				var controlsActivated = true;
				var gui;
				var cubemaps = new Array(4);

				// Light System Variables
				var ambientLight;   //scene ambient light object
				var lights;
				var numberOfLights = 3;

				var PointLightPosition1 = new THREE.Vector3(0,10,7);
				var PointLightPosition2 = new THREE.Vector3(-19,0,-17);
				var PointLightPosition3 = new THREE.Vector3(19,0,-17);

				var lightParameters = {
					red: 1.0,
					green: 1.0,
					blue: 1.0,
					intensity: 1,};
				
				// Model Variables
				var modelPath = "/models/finalModel3.glb";
                var modelParts;     // contains all model's parts (meshes)
                var numberOfParts = 5;
                var modeLoaded = false;

				var parametriSelezioneModello = {	// values on code indicates starting properties of materials
					parte1: {Materiale: "Oro", Colore: 0x000000,},
					parte2: {Materiale: "Plastica opaca", Colore: 0x222222,},
					parte3: {Materiale: "Oro", Colore: 0xff0000,},
					parte4: {Materiale: "Tessuto chiaro", Colore: 0x222222,},
					parte5: {Materiale: "Oro", Colore: 0xff0000,},
				}

				var parametriSelezioneScena = {
					Ambiente : "Spiaggia",
					Mostra_Manichino: true,
				}

                // Shaders //
                var basicVertex; var basicFragment;				// basic fragment shader
				var glossyVertex; var glossyFragment;			// glossy reflection from cubemap shader
				var vertexLambMicro; var fragmentLambMicro;		// lambertian + microfacet shader
				var vertexLambGlossy; var fragmentLambGlossy;	// lambertian + glossy shader

				var normalMaps = new Array(10);

				// pre-defined Materials: 
					
				/*	// Opaque plastic
					var OpaqueWhitePlastic, OpaqueBlackPlastic, OpaqueRedPlastic;
					// Lucid plastic
					var LucidWhitePlastic, LucidBlackPlastic, LucidRedPlastic;
				*/

				// Metals
				var GoldMetal, AluminiumMetal, SilverMetal, HeadMaterial, TessutoScuro, TessutoChiaro;
                
                var LucidPlastic_Cspec = {red: 0.04, green: 0.04, blue: 0.04,roughness: 0.275};
                var OpaquePlastic_Cspec = {red: 0.04, green: 0.04, blue: 0.04,roughness: 0.8};

				//var Gold_Cspec = {red: 1.078, green: 0.782, blue: 0.344, roughness: 0.35}; for brdf
				//var Aluminium_Cspec = {red: 0.913, green: 0.922, blue: 0.924, roughness: 0.475}; for brdf

				
				function Start() {
                    // Starting configuration phase:
                    // 1. Model meshes loading phase
                    modelParts = new Array(numberOfParts);
                    modelMaterials = new Array(numberOfParts);
                    loadGLTFModel();
                    loadShaders();
					LoadNormalMap();
					LoadCubeMaps();
					generatePredefinedMaterials();

                    // 2. Scene Initialization phase
					setupScene();
					setupRenderer();
					setupCamera();
					setupStatsOSD();
					setupLightSystem();
					buildNewGUI();
					updateSceneCubemap();

					/* ___________________________________________________________________________________________________________________________________________________________________________
					>> Start code goes here:
					*/


					
					
				}

				function updateSceneCubemap(){
					Ambiente = parametriSelezioneScena.Ambiente;
					if(Ambiente == "Spiaggia"){
						scene.background = cubemaps[2];
						updateMaterialsCubemap(2);
					}else if(Ambiente == "Studio"){
						scene.background = cubemaps[1];
						updateMaterialsCubemap(1);
					}else if(Ambiente == "Shangai notturna"){
						scene.background = cubemaps[3];
						updateMaterialsCubemap(3);
					}else if(Ambiente == "Abitazione"){
						scene.background = cubemaps[0];
						updateMaterialsCubemap(0);
					}
				}

				function updateMaterialsCubemap(cubemapIndex){
					if(modelParts[1]){
					modelParts[1].material.uniforms.envMap.value = cubemaps[cubemapIndex];
					}
					if(modelParts[2]){
					modelParts[2].material.uniforms.envMap.value = cubemaps[cubemapIndex];
					}
					if(modelParts[3]){
					modelParts[3].material.uniforms.envMap.value = cubemaps[cubemapIndex];
					}
					if(modelParts[4]){
					modelParts[4].material.uniforms.envMap.value = cubemaps[cubemapIndex];
					}
					if(modelParts[5]){
					modelParts[5].material.uniforms.envMap.value = cubemaps[cubemapIndex];
					}

					AluminiumMetal.uniforms.envMap.value = cubemaps[cubemapIndex];
					GoldMetal.uniforms.envMap.value = cubemaps[cubemapIndex];
					SilverMetal.uniforms.envMap.value = cubemaps[cubemapIndex];
					
				}

				function initializeModelMaterials(){
					updateMaterialType(1);
					updateMaterialType(2);
					updateMaterialType(3);
					updateMaterialType(4);
					updateMaterialType(5);
				}

				function updateMaterialType(partnumber){

				var part_to_update = modelParts[partnumber];
				var parametri = selectSelectionParameters(partnumber);
				new_color = new THREE.Color(parametri.Colore);

					if(parametri.Materiale == "Plastica opaca"){		
						new_uniforms = generateGlossyLambertUniforms(new THREE.Vector3(new_color.r,new_color.g,new_color.b),normalMaps[0],cubemap,0.0075,0.0075,1, new THREE.Vector3(0.0,0.0,0.0));
						new_material = createMaterial(new_uniforms,vertexLambGlossy,fragmentLambGlossy);
						changePartMaterial(part_to_update,new_material);
					}else if(parametri.Materiale == "Plastica lucida"){
						new_uniforms = generateGlossyLambertUniforms(new THREE.Vector3(new_color.r,new_color.g,new_color.b),normalMaps,cubemap,0.0075,0.0075,0.55, new THREE.Vector3(0.0,0.0,0.0));
						new_material = createMaterial(new_uniforms,vertexLambGlossy,fragmentLambGlossy);
						changePartMaterial(part_to_update,new_material);
					}else if(parametri.Materiale == "Oro"){
						changePartMaterial(part_to_update,GoldMetal);
					}else if(parametri.Materiale == "Alluminio"){
						changePartMaterial(part_to_update,AluminiumMetal);
					}else if(parametri.Materiale == "Argento"){
						changePartMaterial(part_to_update,SilverMetal);
					}else if(parametri.Materiale == "Tessuto scuro"){
						changePartMaterial(part_to_update,TessutoScuro);
					}else if(parametri.Materiale == "Tessuto chiaro"){
						changePartMaterial(part_to_update,TessutoChiaro);
					}
				}

				function selectSelectionParameters(partnumber){
					if(partnumber == 1){return parametriSelezioneModello.parte1};
					if(partnumber == 2){return parametriSelezioneModello.parte2};
					if(partnumber == 3){return parametriSelezioneModello.parte3};
					if(partnumber == 4){return parametriSelezioneModello.parte4};
					if(partnumber == 5){return parametriSelezioneModello.parte5};
				}

				function generateLambertianUniforms(cspec,roughness,cdiff){
					lambertianUniforms = {
						cspec:{ type: "v3", value: new THREE.Vector3(cspec.x,cspec.y,cspec.z) },
						cdiff:{ type: "v3", value: new THREE.Vector3(cdiff.x,cdiff.y,cdiff.z) },
						roughness: {type: "f", value: roughness},
						pointLightPosition1:{ type: "v3", value: PointLightPosition1 },
						clight1:{ type: "v3", value: new THREE.Vector3(lightParameters.red * lightParameters.intensity,lightParameters.green * lightParameters.intensity,lightParameters.blue * lightParameters.intensity) },
						pointLightPosition2:{ type: "v3", value: PointLightPosition2 },
						clight2:{ type: "v3", value: new THREE.Vector3(lightParameters.red * lightParameters.intensity,lightParameters.green * lightParameters.intensity,lightParameters.blue * lightParameters.intensity) },
						pointLightPosition3:{ type: "v3", value: PointLightPosition3 },
						clight3:{ type: "v3", value: new THREE.Vector3(lightParameters.red * lightParameters.intensity,lightParameters.green * lightParameters.intensity,lightParameters.blue * lightParameters.intensity) },						
					};
                    return lambertianUniforms;
				}

				function generateGlossyUniforms(cspec,normalMap,envMap,XnormScale,YnormScale,roughness){
					var glossyUniforms = {
				    	cspec:	{ type: "v3", value: new THREE.Vector3(cspec.x,cspec.y,cspec.z) },
				    	normalMap:	{ type: "t", value: normalMap},
						normalScale: {type: "v2", value: new THREE.Vector2(XnormScale,YnormScale)},
						envMap:	{ type: "t", value: envMap},
						roughness: { type: "f", value: roughness},
						};
					return glossyUniforms;
				}

				function generateGlossyLambertUniforms(cspec,normalMap,envMap,XnormScale,YnormScale,roughness,cdiff){

				glossyLambUniforms = {
						cspec:{ type: "v3", value: new THREE.Vector3(cspec.x,cspec.y,cspec.z) },
						cdiff:{ type: "v3", value: new THREE.Vector3(cdiff.x,cdiff.y,cdiff.z) },
						roughness: {type: "f", value: roughness},
						pointLightPosition1:{ type: "v3", value: PointLightPosition1 },
						clight1:{ type: "v3", value: new THREE.Vector3(lightParameters.red * lightParameters.intensity,lightParameters.green * lightParameters.intensity,lightParameters.blue * lightParameters.intensity) },
						pointLightPosition2:{ type: "v3", value: PointLightPosition2 },
						clight2:{ type: "v3", value: new THREE.Vector3(lightParameters.red * lightParameters.intensity,lightParameters.green * lightParameters.intensity,lightParameters.blue * lightParameters.intensity) },
						pointLightPosition3:{ type: "v3", value: PointLightPosition3 },
						clight3:{ type: "v3", value: new THREE.Vector3(lightParameters.red * lightParameters.intensity,lightParameters.green * lightParameters.intensity,lightParameters.blue * lightParameters.intensity) },
						normalMap:	{ type: "t", value: normalMap},
						normalScale: {type: "v2", value: new THREE.Vector2(XnormScale,YnormScale)},
						envMap:	{ type: "t", value: envMap},
					};
					return glossyLambUniforms;
				}


				
				function generatePredefinedMaterials(){

					GoldUniforms = generateGlossyLambertUniforms(new THREE.Vector3(1.078,0.782,0.344),normalMaps[0],cubemap,0.065,0.065,0.18, new THREE.Vector3(0.0,0.0,0.0));
					GoldMetal = createMaterial(GoldUniforms,vertexLambGlossy,fragmentLambGlossy);
					
					SilverUniforms = generateGlossyLambertUniforms(new THREE.Vector3(0.992,0.980,0.935),normalMaps[3],cubemap,0.065,0.065,0.18, new THREE.Vector3(0.0,0.0,0.0));
					SilverMetal = createMaterial(SilverUniforms,vertexLambGlossy,fragmentLambGlossy);

					AluminiumUniforms = generateGlossyLambertUniforms(new THREE.Vector3(0.913,0.922,0.924),normalMaps[2],cubemap,0.065,0.065,0.5, new THREE.Vector3(0.0,0.0,0.0));
					AluminiumMetal = createMaterial(AluminiumUniforms,vertexLambGlossy,fragmentLambGlossy);
					
					HeadUniforms = generateGlossyLambertUniforms(new THREE.Vector3(0.075,0.075,0.075),normalMaps[3],cubemap,0.025,0.025,1, new THREE.Vector3(0.9,0.9,0.9));
					HeadMaterial = createMaterial(HeadUniforms,vertexLambGlossy,fragmentLambGlossy);

					TessutoScuroUniforms = generateGlossyLambertUniforms(new THREE.Vector3(0.09,0.09,0.09),normalMaps[1],cubemap,3,3,0.8, new THREE.Vector3(0.085,0.085,0.085));
					TessutoScuro = createMaterial(TessutoScuroUniforms,vertexLambGlossy,fragmentLambGlossy);

					TessutoChiaroUniforms = generateGlossyLambertUniforms(new THREE.Vector3(0.09,0.09,0.09),normalMaps[1],cubemap,3,3,0.8, new THREE.Vector3(0.585,0.585,0.585));
					TessutoChiaro = createMaterial(TessutoChiaroUniforms,vertexLambGlossy,fragmentLambGlossy);

				console.log("predefined materials generated!");
				}
				
                function createMaterial(uniforms,vertexShader,fragmentShader){
					materialExtensions = {
						shaderTextureLOD: true // set to use shader texture LOD
					};
                    newMaterial = new THREE.ShaderMaterial({
                        uniforms: uniforms,
                        vertexShader: vertexShader,
                        fragmentShader: fragmentShader,
						extensions: materialExtensions });
                    return newMaterial;
                }

                function changePartMaterial(part,material){
                    part.material = material;
                }

                function loadGLTFModel(){
                    var loader = new THREE.GLTFLoader();
                    loader.load(modelPath,
                    	function ( gltf ) {	

						// saving model's part
						modelParts[1] = gltf.scene.children[1];
						modelParts[2] = gltf.scene.children[2];
						modelParts[3] = gltf.scene.children[3];
						modelParts[4] = gltf.scene.children[4];
                    	modelParts[5] = gltf.scene.children[5];

						head = gltf.scene.children[6];

						// adding parts
						scene.add(modelParts[1]);
						scene.add(modelParts[2]);
						scene.add(modelParts[3]);
						scene.add(modelParts[4]);
						scene.add(modelParts[5]);

						scene.add(head);
						head.material = HeadMaterial;

						// computing tangents for every single part
						THREE.BufferGeometryUtils.computeTangents(modelParts[1].geometry);
						THREE.BufferGeometryUtils.computeTangents(modelParts[2].geometry);	
						THREE.BufferGeometryUtils.computeTangents(modelParts[3].geometry);	
						THREE.BufferGeometryUtils.computeTangents(modelParts[4].geometry);
						THREE.BufferGeometryUtils.computeTangents(modelParts[5].geometry);
						THREE.BufferGeometryUtils.computeTangents(head.geometry);
						initializeModelMaterials();
						updateSceneCubemap();	

						modelParts[4].material = TessutoChiaro;		

					    modeLoaded = true;
                       },)
                       ;

                }

				
				// search in html and save shaders textContents
                function loadShaders(){
                    basicVertex = document.getElementById("BasicVertexShader").textContent;
                    basicFragment = document.getElementById("BasicColorFragmentShader").textContent;
					vertexLambMicro = document.getElementById("vertexBRDF_Lambertian_Microfacet").textContent;
					fragmentLambMicro = document.getElementById("fragmentBRDF_Lambertian_Microfacet").textContent;
					glossyVertex = document.getElementById("GlossyVertex").textContent;
					glossyFragment = document.getElementById("GlossyFragment").textContent;
					vertexLambGlossy = document.getElementById("GlossyVertex").textContent;
					fragmentLambGlossy = document.getElementById("LamebrtianGlossyFragment").textContent;
				}
				
				// load and save cubemap texture
				function LoadCubeMap(path){
					var loader = new THREE.CubeTextureLoader();
					loader.setPath(path);
					cubemap = loader.load( [
					'px.png', 'nx.png',
					'py.png', 'ny.png',
					'pz.png', 'nz.png'
				] );		
				cubemap.minFilter = THREE.LinearMipMapLinearFilter;
				return cubemap;
				}

				function LoadCubeMaps(){
					cubemaps[0] = LoadCubeMap( 'textures/cubemap_1/');
					cubemaps[1] = LoadCubeMap( 'textures/cubemap_2/');
					cubemaps[2] = LoadCubeMap( 'textures/cubemap_3/');
					cubemaps[3] = LoadCubeMap( 'textures/cubemap_4/');
					console.log("cubemaps loaded succesfully!")
				}

				// load normalMaps
				function LoadNormalMap(){
					normalMaps[0] = loadTexture('textures/normalmap_1.jpg');
					normalMaps[1] = loadTexture('textures/normalmap_2.jpg');
					normalMaps[2] = loadTexture('textures/normalmap_3.jpg');
					normalMaps[3] = loadTexture('textures/normalmap_4.jpg');
					console.log("normalmaps loaded succesfully!")
				}

				// load a texture froma given file path
				function loadTexture(file) {
					var texture = new THREE.TextureLoader().load( file , function ( texture ) {
					texture.minFilter = THREE.LinearMipMapLinearFilter;
					texture.anisotropy = renderer.getMaxAnisotropy();
					texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
    			    texture.offset.set( 0, 0 );
					texture.needsUpdate = true;
					})
					return texture;
				}
				
				// called once per frame
				function Update() {	
					requestAnimationFrame(Update);
					stats.update();
					if(controlsActivated){controls.update();}
					renderer.render(scene, camera);	
				}
	
				// basic scene setup
				function setupScene(){
					scene = new THREE.Scene();
					//Coordinates.drawAllAxes();
				}

				// basic camera setup
				function setupCamera(){
					camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
					camera.position.set(6.1,4.5,-9);
					camera.lookAt( new THREE.Vector3(0,0,0));
					if(controlsActivated){
						controls = new THREE.OrbitControls(camera, renderer.domElement);
						controls.minDistance = 1;
						controls.maxDistance = 100;
						controls.enablePan = true;
					}
				}
	
				// renderer initialization
				function setupRenderer(){
					renderer = new THREE.WebGLRenderer({antialias:true});
					renderer.setSize( window.innerWidth, window.innerHeight );
					renderer.setClearColor(0xf0f0f0);
					renderer.shadowMap.Type = THREE.PCFShadowMap;
					document.body.appendChild( renderer.domElement);
					renderer.shadowMap.enabled = true;
					renderer.shadowMap.type = THREE.BasicShadowMap;
					renderer.setPixelRatio( window.devicePixelRatio );
				}

				// setup performance OSD
				function setupStatsOSD(){
					stats = new Stats();
					stats.domElement.style.position = 'absolute';
					stats.domElement.style.top = '0px';
					document.body.appendChild( stats.domElement );
				}
	
				// seutp the scene light system
				function setupLightSystem(){
					// basic ambient light
					ambientLight = new THREE.AmbientLight(0xffffff,0.8); 
					scene.add(ambientLight);

					lights = new Array(numberOfLights); // not used yet
				}

				// GUI for models modification user interaction. It allows the user to change materials for every model's part
				function buildNewGUI() {
					clearGUI();
					
					selezioneParte1 = gui.addFolder('Parte esterna');
					selezioneParte2 = gui.addFolder('Pulsanti');
					selezioneParte3 = gui.addFolder('Parte superiore');
					selezioneParte4 = gui.addFolder('Elementi ergonomici');
					selezioneParte5 = gui.addFolder('Parte interna');

					selezioneScena = gui.addFolder('Ambiente');

					selezioneScena.add(parametriSelezioneScena, 'Ambiente',["Studio","Spiaggia","Shangai notturna","Abitazione"]).onChange(
					function(value){
						console.log("Hei! Cubemap needs to be updated!!");
						updateSceneCubemap();
					}
					
					);

					selezioneParte1.add(parametriSelezioneModello.parte1,'Materiale',["Plastica lucida","Plastica opaca","Oro","Argento","Alluminio",]).onChange(
					function( value ) {
						console.log("Hey!, changed material on Part1");
						updateMaterialType(1);
						if(parametriSelezioneModello.parte1.Materiale == "Oro" || parametriSelezioneModello.parte1.Materiale =="Alluminio" || parametriSelezioneModello.parte1.Materiale =="Argento"){
							colorPicker1.domElement.hidden = true;		
						}else{
							colorPicker1.domElement.hidden = false;
						}
					});
			
					colorPicker1 = selezioneParte1.addColor(parametriSelezioneModello.parte1,'Colore').onChange(
						function(value){
						console.log("Hey! color changed on Part1");
						updateMaterialType(1);	
					});

					selezioneParte2.add(parametriSelezioneModello.parte2,'Materiale',["Plastica lucida","Plastica opaca","Oro","Argento","Alluminio",]).onChange(
					function( value ) {
						console.log("Hey!, changed material  on Part2");
						updateMaterialType(2);
						if(parametriSelezioneModello.parte2.Materiale == "Oro" || parametriSelezioneModello.parte2.Materiale =="Alluminio" || parametriSelezioneModello.parte2.Materiale =="Argento"){
							colorPicker2.domElement.hidden = true;		
						}else{
							colorPicker2.domElement.hidden = false;
						}
					});
			
					colorPicker2 = selezioneParte2.addColor(parametriSelezioneModello.parte2,'Colore').onChange(
						function(value){
						console.log("Hey! color changed on Part2");
						updateMaterialType(2);	
					});

					selezioneParte3.add(parametriSelezioneModello.parte3,'Materiale',["Plastica lucida","Plastica opaca","Oro","Argento","Alluminio",]).onChange(
					function( value ) {
						console.log("Hey!, changed material on Part3");
						updateMaterialType(3);
						if(parametriSelezioneModello.parte3.Materiale == "Oro" || parametriSelezioneModello.parte3.Materiale =="Alluminio" || parametriSelezioneModello.parte3.Materiale =="Argento"){
							colorPicker3.domElement.hidden = true;		
						}else{
							colorPicker3.domElement.hidden = false;
						}
					});
			
					colorPicker3 = selezioneParte3.addColor(parametriSelezioneModello.parte3,'Colore').onChange(
						function(value){
						console.log("Hey! color changed on Part3");
						updateMaterialType(3);	
					});

					selezioneParte4.add(parametriSelezioneModello.parte4,'Materiale',[ "Tessuto scuro", "Tessuto chiaro", ]).onChange(
					function( value ) {
						console.log("Hey!, changed material on Part4");
						updateMaterialType(4);
					});

					selezioneParte5.add(parametriSelezioneModello.parte5,'Materiale',["Plastica lucida","Plastica opaca","Oro","Argento","Alluminio",]).onChange(
					function( value ) {
						console.log("Hey!, changed material on Part5");
						updateMaterialType(5);
						if(parametriSelezioneModello.parte5.Materiale == "Oro" || parametriSelezioneModello.parte5.Materiale =="Alluminio" || parametriSelezioneModello.parte5.Materiale =="Argento"){
							colorPicker5.domElement.hidden = true;		
						}else{
							colorPicker5.domElement.hidden = false;
						}
					});
			
					colorPicker5 = selezioneParte5.addColor(parametriSelezioneModello.parte5,'Colore').onChange(
						function(value){
						console.log("Hey! color changed on Part5");
						updateMaterialType(5);	
					});


					// HIDE COLOR SELECTORS IF STARTING MATERIAL CAN'T CHANGE COLOR
					if(parametriSelezioneModello.parte1.Materiale == "Oro" || parametriSelezioneModello.parte1.Materiale =="Alluminio" || parametriSelezioneModello.parte1.Materiale =="Argento"){
							colorPicker1.domElement.hidden = true;		
						}else{
							colorPicker1.domElement.hidden = false;
					}
	
					if(parametriSelezioneModello.parte3.Materiale == "Oro" || parametriSelezioneModello.parte2.Materiale =="Alluminio" || parametriSelezioneModello.parte2.Materiale =="Argento"){
							colorPicker2.domElement.hidden = true;		
						}else{
							colorPicker2.domElement.hidden = false;
					}
		
					if(parametriSelezioneModello.parte3.Materiale == "Oro" || parametriSelezioneModello.parte3.Materiale =="Alluminio" || parametriSelezioneModello.parte3.Materiale =="Argento"){
							colorPicker3.domElement.hidden = true;		
						}else{
							colorPicker3.domElement.hidden = false;
					}

					if(parametriSelezioneModello.parte5.Materiale == "Oro" || parametriSelezioneModello.parte5.Materiale =="Alluminio" || parametriSelezioneModello.parte5.Materiale =="Argento"){
							colorPicker5.domElement.hidden = true;		
						}else{
							colorPicker5.domElement.hidden = false;
					}
					
				
				}

				function clearGUI() {
					if ( gui ) gui.destroy();
					gui = new dat.GUI();
					gui.open();
				}
				
				// Main code goes here:
	
				Start();
				Update();
				
			</script>
		</body>
	</html>