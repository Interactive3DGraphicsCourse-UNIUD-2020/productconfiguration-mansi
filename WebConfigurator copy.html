
<html>
		<head>
			<title>--- Web Product Configurator ---</title>
			<style>
			body {
				font-family: Monospace;
				background-color:#f0f0f0;
				margin: 0px;
				overflow: hidden;
			}
			canvas {
				width: 100%;
				height: 100%;
			}
		</style>
			<script src="libs/three.js"></script>
			<script src="libs/stats.min.js"></script>
			<script src="libs/OBJLoader.js"></script>
			<script src="libs/Coordinates.js"></script>
            <script src="libs/OrbitControls.js"></script>
			<script src="libs/GLTFLoader.js"></script>
			<script src='libs/dat.gui.min.js'></script>
		</head>
		-------------- Andrea Mansi UNIUD --- Progetto Interactive 3D Graphics --- Web Product Configurator ---
			
			<script type="text/x-glsl" id="GlossyVertex">
				precision highp float;
				precision highp int;
				attribute vec4 tangent;
				varying vec3 vNormal;
				varying vec3 vTangent;
				varying vec3 vBitangent;
				varying vec3 vPosition;
				varying vec2 vUv;
		
				void main() {
					vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
					vPosition = vPos.xyz;
					vNormal = normalize(normalMatrix * normal);
					vec3 objectTangent = vec3( tangent.xyz );
					vec3 transformedTangent = normalMatrix * objectTangent;
					vTangent = normalize( transformedTangent );
					vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
					vUv = uv;
					gl_Position = projectionMatrix * vPos;
				}
			</script>
		
			<script type="text/x-glsl" id="GlossyFragment">
					precision highp float;
					precision highp int;
					varying vec3 vNormal;
					varying vec3 vTangent;
					varying vec3 vBitangent;
					varying vec3 vPosition;
					varying vec2 vUv;
					uniform vec3 cspec;
					uniform sampler2D normalMap;
					uniform samplerCube envMap;
					uniform vec2 normalScale;
					uniform float roughness;
		
					const float PI = 3.14159;
					#define saturate(a) clamp( a, 0.0, 1.0 )
		
					float pow2( const in float x ) { return x*x; }
		
					float getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {
						 float maxMIPLevelScalar = float( maxMIPLevel );
						 float desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );
						 return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
					 }
		
					float GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {
						  return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
					  }
		
					// http://en.wikibooks.org/wiki/GLSL_Programming/Applying_Matrix_Transformations
					vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
						return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
					}
		
					vec3 BRDF_Specular_GGX_Environment( vec3 normal, vec3 viewDir, const in vec3 cspec, const in float roughness ) {
		
						float dotNV = saturate( dot( normal, viewDir ) );
						const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
						const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
						vec4 r = roughness * c0 + c1;
						float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
						vec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;
						return cspec * AB.x + AB.y;
		
					}
		
					void main() {
						vec3 normal = normalize( vNormal );
						vec3 tangent = normalize( vTangent );
						vec3 bitangent = normalize( vBitangent );
						mat3 vTBN = mat3( tangent, bitangent, normal );
						
						vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;
						mapN.xy = normalScale * mapN.xy;
						normal.xy = normalScale * normal.xy;

						vec3 n = normalize( vTBN * mapN ); // normal was mapN
						vec3 v = normalize( -vPosition);
						vec3 vReflect = reflect(vPosition,n);
						vec3 r = inverseTransformDirection( vReflect, viewMatrix );
		
						float blinnShininessExponent = GGXRoughnessToBlinnExponent(roughness);
						float specularMIPLevel = getSpecularMIPLevel(blinnShininessExponent,8 );
		
						 vec3 envLight = textureCubeLodEXT( envMap, vec3(-r.x, r.yz), specularMIPLevel ).rgb;
						 // texture in sRGB, linearize
						envLight = pow( envLight, vec3(2.2));
						
						vec3 outRadiance = envLight*BRDF_Specular_GGX_Environment(n, v, cspec, roughness);
						// gamma encode the final value
						gl_FragColor = vec4(pow( outRadiance, vec3(1.0/2.2)), 1.0);
						//gl_FragColor = vec4(r,1.0);
					}
			</script>

			<script type="text/x-glsl" id="vertexBRDF_Lambertian_Microfacet">
				varying vec3 vNormal;
				varying vec3 vPosition;
			
				void main() {
					vec4 vPos = modelViewMatrix * vec4( position, 1.0 );
					vPosition = vPos.xyz;
					vNormal = normalMatrix * normal;
					gl_Position = projectionMatrix * vPos;
				}
			</script>

			<script type="text/x-glsl" id="fragmentBRDF_Lambertian_Microfacet">
					varying vec3 vNormal;
					varying vec3 vPosition;
				
					//uniform mat3 pointLightsPositions;
					//uniform mat3 clight;
				
					uniform vec3 pointLightPosition1; // in world space
					uniform vec3 clight1;
					uniform vec3 pointLightPosition2; // in world space
					uniform vec3 clight2;
					uniform vec3 pointLightPosition3; // in world space
					uniform vec3 clight3;
				
					uniform vec3 cspec;
					uniform vec3 cdiff;
					uniform float roughness;
					const float PI = 3.14159;
				
					//Schlick microfacet BRDF
					vec3 FSchlick(float lDoth) {
						return (cspec + (vec3(1.0)-cspec)*pow(1.0 - lDoth,5.0));
					}
				
					//NDF -> Normal distribution function GGX Approx
					float DGGX(float nDoth, float alpha) {
						float alpha2 = alpha*alpha;
						float d = nDoth*nDoth*(alpha2-1.0)+1.0;
						return (  alpha2 / (PI*d*d));
					}
				
					//Geometry Factor
					float G1(float dotProduct, float k) {
						return (dotProduct / (dotProduct*(1.0-k) + k) );
					}
				
					float GSmith(float nDotv, float nDotl) {
							float k = roughness*roughness;
							return G1(nDotl,k)*G1(nDotv,k);
					}
				
					void main() {
					
						
						vec4 plPos1 = viewMatrix * vec4( pointLightPosition1, 1.0 );
						vec4 plPos2 = viewMatrix * vec4( pointLightPosition2, 1.0 );
						vec4 plPos3 = viewMatrix * vec4( pointLightPosition3, 1.0 );

						vec3 l1 = normalize(plPos1.xyz - vPosition.xyz);
						vec3 l2 = normalize(plPos2.xyz - vPosition.xyz);
						vec3 l3 = normalize(plPos3.xyz - vPosition.xyz);
					
						vec3 n1 = normalize( vNormal );  // interpolation destroys normalization, so we have to normalize
						vec3 n2 = normalize( vNormal );
						vec3 n3 = normalize( vNormal );  
					
						vec3 v1 = normalize(-vPosition);
						vec3 v2 = normalize(-vPosition);
						vec3 v3 = normalize(-vPosition);
					
						mat3 h;
						h[0] = normalize( v1 + l1);
						h[1] = normalize( v2 + l2);
						h[2] = normalize( v3 + l3);
					
						// small quantity to prevent divisions by 0
						float nDotl[3];
						nDotl[0] = max(dot( n1, l1 ),0.000001);
						nDotl[1] = max(dot( n2, l2 ),0.000001);
						nDotl[2] = max(dot( n3, l3 ),0.000001);
					
						float lDoth[3];
						lDoth[0] = max(dot( l1, h[0] ),0.000001);
						lDoth[1] = max(dot( l2, h[1] ),0.000001);
						lDoth[1] = max(dot( l3, h[2] ),0.000001);
					
						float nDoth[3];
						nDoth[0] = max(dot( n1, h[0] ),0.000001);
						nDoth[1] = max(dot( n2, h[1] ),0.000001);
						nDoth[2] = max(dot( n3, h[2] ),0.000001);

						float vDoth[3];
						vDoth[0] = max(dot( v1, h[0] ),0.000001);
						vDoth[1] = max(dot( v2, h[1] ),0.000001);
						vDoth[2] = max(dot( v3, h[2] ),0.000001);
					
						float nDotv[3];
						nDotv[0] = max(dot( n1, v1 ),0.000001);
						nDotv[1] = max(dot( n2, v2 ),0.000001);
						nDotv[2] = max(dot( n3, v3 ),0.000001);
					
						vec3 fresnel1 = FSchlick(lDoth[0]);
						vec3 fresnel2 = FSchlick(lDoth[1]);
						vec3 fresnel3 = FSchlick(lDoth[2]);
					
						vec3 BRDF1 = (vec3(1.0)-fresnel1)*cdiff/PI + fresnel1*GSmith(nDotv[0],nDotl[0])*DGGX(nDoth[0],roughness*roughness)/
							(4.0*nDotl[0]*nDotv[0]);

						vec3 BRDF2 = (vec3(1.0)-fresnel2)*cdiff/PI + fresnel2*GSmith(nDotv[1],nDotl[1])*DGGX(nDoth[1],roughness*roughness)/
							(4.0*nDotl[1]*nDotv[1]);

						vec3 BRDF3 = (vec3(1.0)-fresnel3)*cdiff/PI + fresnel3*GSmith(nDotv[2],nDotl[2])*DGGX(nDoth[2],roughness*roughness)/
							(4.0*nDotl[2]*nDotv[2]);
					
						vec3 outRadiance = (PI* (clight1 * nDotl[0]) * BRDF1) + (PI* (clight2 * nDotl[1]) * BRDF2)+ (PI* (clight3 * nDotl[2]) * BRDF3);

						// gamma encode the final value
						gl_FragColor = vec4(pow( outRadiance, vec3(1.0/1.0)), 1.0); //2.2 or 1? wtf
					}
			</script>

            <script type="text/x-glsl" id="BasicVertexShader">
                varying vec3 color;
				
				void main() {
					vec3 newPosition = position;
					// transforms the vertex from object space to clip space coords		
                    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
                }
			</script>
		
			<script type="text/x-glsl" id="BasicColorFragmentShader">
				varying vec3 color;
				void main() {
					gl_FragColor = vec4(0.5,0.5,0.5,1.0);
				}
            </script>
	
			<script>
				// Main Variables
				var scene, camera, renderer, camera, stats;
				var controlsActivated = true;
				var gui, cubemap;

				// Light System Variables
				var ambientLight;   //scene ambient light object
				var lights;
				var numberOfLights = 3;

				var PointLightPosition1 = new THREE.Vector3(7,6,-7);
				var PointLightPosition2 = new THREE.Vector3(7,8,-7);
				var PointLightPosition3 = new THREE.Vector3(15,6,-7);

				var coldlightParameters = {
					red: 1.0,
					green: 1.0,
					blue: 1.0,
					intensity: 1.0,};
				
				// Model Variables
				var modelPath = "/models/finalModel.glb";
                var modelParts;     // contains model's meshes
                var modelMaterials; // contains starting model's materials for each mesh (material of index x is the x part's material)
                var numberOfParts = 5;
                var modeLoaded = false;

				var parametriSelezioneModello = {
					parte1: {materialeSelezionato: "Plastica lucida", coloreSelezionato: 0xff0000,},
					parte2: {materialeSelezionato: "Plastica lucida", coloreSelezionato: 0xff0000,},
					parte3: {materialeSelezionato: "Plastica lucida", coloreSelezionato: 0xff0000,},
					parte4: {materialeSelezionato: "Plastica lucida", coloreSelezionato: 0xff0000,},
					parte5: {materialeSelezionato: "Plastica lucida", coloreSelezionato: 0xff0000,},
				}

                // Shaders //
                var basicVertex;
                var basicFragment;

				var glossyVertex;
				var glossyFragment;

				var vertexBRDFLambertianMicrofacet;
				var fragmentBRDFLambertianMicrofacet;

				var normalMap;

				// pre-defined Materials:
					
					// Opaque plastic
					var OpaqueWhitePlastic, OpaqueBlackPlastic, OpaqueRedPlastic;
					// Lucid plastic
					var LucidWhitePlastic, LucidBlackPlastic, LucidRedPlastic;
					// Metals
					var GoldMetal, AluminiumMetal;

				// Materials CDIFF and CSPEC
				var WhitePlastic_Cdiff = {red: 0.90, green: 0.90, blue: 0.90};
				var BlackPlastic_Cdiff = {red: 0, green: 0, blue: 0};
				var RedPlastic_Cdiff =   {red: 1, green: 0.05, blue: 0.05};
				var Metal_Cdiff  = {red: 0.001, green: 0.001, blue: 0.001};
                
                var LucidPlastic_Cspec = {red: 0.04, green: 0.04, blue: 0.04,roughness: 0.275};
                var OpaquePlastic_Cspec = {red: 0.04, green: 0.04, blue: 0.04,roughness: 0.8};
				var Gold_Cspec = {red: 1.078, green: 0.782, blue: 0.344, roughness: 0.35};
				var Aluminium_Cspec = {red: 0.913, green: 0.922, blue: 0.924, roughness: 0.475};

				
				function Start() {
                    // Starting configuration phase:
                    // 1. Model meshes loading phase
                    modelParts = new Array(numberOfParts);
                    modelMaterials = new Array(numberOfParts);
                    loadGLTFModel();
                    loadShaders();

                    // 2. Scene Initialization phase
					setupScene();
					setupRenderer();
					setupCamera();
					setupStatsOSD();
					setupLightSystem();
					LoadCubeMap();
					LoadNormalMap();
					buildNewGUI();

					/* ___________________________________________________________________________________________________________________________________________________________________________
					>> Start code goes here:
					*/
					
					
				}

				function updateMaterialType(partnumber){

				var part_to_update = modelParts[partnumber];
				var parametri = selectSelectionParameters(partnumber);
				new_color = new THREE.Color(parametri.coloreSelezionato);

					if(parametri.materialeSelezionato == "Plastica opaca"){		
						new_uniforms = generateBRDFLambertianMicrofacetUniforms(OpaquePlastic_Cspec,{red:new_color.r,green:new_color.g,blue:new_color.b});
						new_material = createMaterial(new_uniforms,vertexBRDFLambertianMicrofacet,fragmentBRDFLambertianMicrofacet);	
						changePartMaterial(part_to_update,new_material);
					}else if(parametri.materialeSelezionato == "Plastica lucida"){
						new_uniforms = generateBRDFLambertianMicrofacetUniforms(LucidPlastic_Cspec,{red:new_color.r,green:new_color.g,blue:new_color.b});
						new_material = createMaterial(new_uniforms,vertexBRDFLambertianMicrofacet,fragmentBRDFLambertianMicrofacet);	
						changePartMaterial(part_to_update,new_material);
					}else if(parametri.materialeSelezionato == "Oro"){
						changePartMaterial(part_to_update,GoldMetal);
					}else if(parametri.materialeSelezionato == "Alluminio"){
						changePartMaterial(part_to_update,AluminiumMetal);
					}
				}

				function selectSelectionParameters(partnumber){
					if(partnumber == 1){return parametriSelezioneModello.parte1};
					if(partnumber == 2){return parametriSelezioneModello.parte2};
					if(partnumber == 3){return parametriSelezioneModello.parte3};
					if(partnumber == 4){return parametriSelezioneModello.parte4};
					if(partnumber == 5){return parametriSelezioneModello.parte5};
				}
				

				function generateBRDFLambertianMicrofacetUniforms(cspec,cdiff){
					uniformsBRDFLambertianMicrofacet = {
						cspec:{ type: "v3", value: new THREE.Vector3(cspec.red,cspec.green,cspec.blue) },
						cdiff:{ type: "v3", value: new THREE.Vector3(cdiff.red,cdiff.green,cdiff.blue) },
						roughness: {type: "f", value: cspec.roughness},
						pointLightPosition1:{ type: "v3", value: PointLightPosition1 },
						clight1:{ type: "v3", value: new THREE.Vector3(coldlightParameters.red * coldlightParameters.intensity,coldlightParameters.green * coldlightParameters.intensity,coldlightParameters.blue * coldlightParameters.intensity) },
						pointLightPosition2:{ type: "v3", value: PointLightPosition2 },
						clight2:{ type: "v3", value: new THREE.Vector3(coldlightParameters.red * coldlightParameters.intensity,coldlightParameters.green * coldlightParameters.intensity,coldlightParameters.blue * coldlightParameters.intensity) },
						pointLightPosition3:{ type: "v3", value: PointLightPosition3 },
						clight3:{ type: "v3", value: new THREE.Vector3(coldlightParameters.red * coldlightParameters.intensity,coldlightParameters.green * coldlightParameters.intensity,coldlightParameters.blue * coldlightParameters.intensity) },
				    };

                    return uniformsBRDFLambertianMicrofacet;
				}

				function generateMaterials(){
                    OpaqueWhitePlasticUniforms = generateBRDFLambertianMicrofacetUniforms(OpaquePlastic_Cspec,WhitePlastic_Cdiff);
                    OpaqueWhitePlastic = createMaterial(OpaqueWhitePlasticUniforms,vertexBRDFLambertianMicrofacet,fragmentBRDFLambertianMicrofacet);
				
                    OpaqueBlackPlasticUniforms = generateBRDFLambertianMicrofacetUniforms(OpaquePlastic_Cspec,BlackPlastic_Cdiff);
                    OpaqueBlackPlastic = createMaterial(OpaqueBlackPlasticUniforms,vertexBRDFLambertianMicrofacet,fragmentBRDFLambertianMicrofacet);
				
                    OpaqueRedPlasticUniforms = generateBRDFLambertianMicrofacetUniforms(OpaquePlastic_Cspec,RedPlastic_Cdiff);
                    OpaqueRedPlastic = createMaterial(OpaqueRedPlasticUniforms,vertexBRDFLambertianMicrofacet,fragmentBRDFLambertianMicrofacet);
				
                    LucidRedPlasticUniforms = generateBRDFLambertianMicrofacetUniforms(LucidPlastic_Cspec,RedPlastic_Cdiff);
                    LucidRedPlastic = createMaterial(LucidRedPlasticUniforms,vertexBRDFLambertianMicrofacet,fragmentBRDFLambertianMicrofacet);
				

                    LucidWhitePlasticUniforms = generateBRDFLambertianMicrofacetUniforms(LucidPlastic_Cspec,WhitePlastic_Cdiff);
                    LucidWhitePlastic = createMaterial(LucidWhitePlasticUniforms,vertexBRDFLambertianMicrofacet,fragmentBRDFLambertianMicrofacet);
				
                    LucidBlackPlasticUniforms = generateBRDFLambertianMicrofacetUniforms(LucidPlastic_Cspec,BlackPlastic_Cdiff);
                    LucidBlackPlastic = createMaterial(LucidBlackPlasticUniforms,vertexBRDFLambertianMicrofacet,fragmentBRDFLambertianMicrofacet);
				
					GoldMetalUniforms = generateBRDFLambertianMicrofacetUniforms(Gold_Cspec,Metal_Cdiff);
					GoldMetal = createMaterial(GoldMetalUniforms,vertexBRDFLambertianMicrofacet,fragmentBRDFLambertianMicrofacet);

					AluminiumMetalUniforms = generateBRDFLambertianMicrofacetUniforms(Aluminium_Cspec,Metal_Cdiff);
					AluminiumMetal = createMaterial(AluminiumMetalUniforms,vertexBRDFLambertianMicrofacet,fragmentBRDFLambertianMicrofacet);
                }
				

                function createMaterial(uniforms,vertexShader,fragmentShader){
					materialExtensions = {
						shaderTextureLOD: true // set to use shader texture LOD
					};

                    newMaterial = new THREE.ShaderMaterial({
                        uniforms: uniforms,
                        vertexShader: vertexShader,
                        fragmentShader: fragmentShader,
						extensions: materialExtensions });
                    return newMaterial;
                }

                function changePartMaterial(part,material){
                    part.material = material;
                }

                function loadGLTFModel(){
                    var loader = new THREE.GLTFLoader();
                    loader.load(modelPath,
                       function ( gltf ) {
                       console.log(gltf.scene);
                       //modelParts[0] = gltf.scene.children[0]; 
					   modelParts[1] = gltf.scene.children[1];
					   modelParts[2] = gltf.scene.children[2];
					   modelParts[3] = gltf.scene.children[3];
					   modelParts[4] = gltf.scene.children[4];
                       modelParts[5] = gltf.scene.children[5];

                       //scene.add(modelParts[0]);
					   scene.add(modelParts[1]);
					   scene.add(modelParts[2]);
					   scene.add(modelParts[3]);
					   scene.add(modelParts[4]);
                       scene.add(modelParts[5]);

                        /* broken?
                       var z_offset = 5;
                       modelParts[1].position.z = z_offset;
                       modelParts[2].position.z = z_offset;
                       modelParts[3].position.z = z_offset;
                       modelParts[4].position.z = z_offset;
                       modelParts[5].position.z = z_offset;
                        */
                        
                       generateMaterials();
                    
                        // a cosa serviva? bo
                       //modelMaterials[0] = new createMaterial(uniforms,basicVertex,basicFragmentTest); 
					   //modelMaterials[1] = new createMaterial(uniforms,basicVertex,basicFragment); 
					   //modelMaterials[2] = new createMaterial(uniforms,basicVertex,basicFragment); 
					   //modelMaterials[3] = new createMaterial(uniforms,basicVertex,basicFragment); 
					   //modelMaterials[4] = new createMaterial(uniforms,basicVertex,basicFragmentTest); 

					   var GlossyUuniforms = {
				    	cspec:	{ type: "v3", value: new THREE.Vector3(1.000,0.782,0.344) },
				    	normalMap:	{ type: "t", value: normalMap},
						normalScale: {type: "v2", value: new THREE.Vector2(0,0)},
						envMap:	{ type: "t", value: cubemap},
						roughness: { type: "f", value: 0.45},
						};
	
						console.log(GlossyUuniforms);
						glossyMaterial = createMaterial(GlossyUuniforms,glossyVertex,glossyFragment);


                       //modelParts[0].material = OpaqueBlackPlastic;
					   modelParts[1].material = glossyMaterial;//GoldMetal; //OpaqueWhitePlastic;
					   modelParts[2].material = glossyMaterial;//GoldMetal; //AluminiumMetal;
					   modelParts[3].material = glossyMaterial;//GoldMetal; //AluminiumMetal;
					   modelParts[4].material = glossyMaterial;//GoldMetal; //OpaqueWhitePlastic;
                       modelParts[5].material = glossyMaterial;//GoldMetal; //OpaqueBlackPlastic;

					   modeLoaded = true;
                       },)
                       ;
                    
                }

				
				// carica gli shaders in delle variaibli
                function loadShaders(){
                    basicVertex = document.getElementById("BasicVertexShader").textContent;
                    basicFragment = document.getElementById("BasicColorFragmentShader").textContent;
					vertexBRDFLambertianMicrofacet = document.getElementById("vertexBRDF_Lambertian_Microfacet").textContent;
					fragmentBRDFLambertianMicrofacet = document.getElementById("fragmentBRDF_Lambertian_Microfacet").textContent;
					glossyVertex = document.getElementById("GlossyVertex").textContent;
					glossyFragment = document.getElementById("GlossyFragment").textContent;
				}
				
				// carica e istanzia la cubemap
				function LoadCubeMap(){
					var loader = new THREE.CubeTextureLoader();
					loader.setPath( 'textures/cubemap/' );

					console.log("loading cubemap");	
					cubemap = loader.load( [
					'px.png', 'nx.png',
					'py.png', 'ny.png',
					'pz.png', 'nz.png'
				] );

				scene.background = cubemap;
				cubemap.minFilter = THREE.LinearMipMapLinearFilter;
				}

				function LoadNormalMap(){
					normalMap = loadTexture('textures/normalmap_1.jpg');
				}

				function loadTexture(file) {
					var texture = new THREE.TextureLoader().load( file , function ( texture ) {

					texture.minFilter = THREE.LinearMipMapLinearFilter;
					texture.anisotropy = renderer.getMaxAnisotropy();
					texture.wrapS = texture.wrapT = THREE.RepeatWrapping;
    			    texture.offset.set( 0, 0 );
					texture.needsUpdate = true;

					})
					return texture;
				}
				
				
				function Update() {	
					requestAnimationFrame(Update);
					stats.update();
					if(controlsActivated){controls.update();}
					renderer.render(scene, camera);
				}
	
				function setupScene(){	// SCENE //
					scene = new THREE.Scene();
					Coordinates.drawAllAxes();
				}
	
				function setupCamera(){	 // CAMERA //
					camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
					camera.position.set(8,5,-6.5);
					camera.lookAt( new THREE.Vector3(0,0,-3));
					if(controlsActivated){controls = new THREE.OrbitControls(camera, renderer.domElement);}
				}
	
				function setupRenderer(){	// RENDERER //
					renderer = new THREE.WebGLRenderer({antialias:true});
					renderer.setSize( window.innerWidth, window.innerHeight );
					renderer.setClearColor(0xf0f0f0);
					renderer.shadowMap.Type = THREE.PCFShadowMap;
					document.body.appendChild( renderer.domElement);
					renderer.shadowMap.enabled = true;
					renderer.shadowMap.type = THREE.BasicShadowMap;
				}
	
				function setupStatsOSD(){	// STATISTICS OSD //
					stats = new Stats();
					stats.domElement.style.position = 'absolute';
					stats.domElement.style.top = '0px';
					document.body.appendChild( stats.domElement );
				}
	
				function setupLightSystem(){	// ADD A BASIC LIGHT SYSTEM TO THE SCENE //
					// basic ambient light
					ambientLight = new THREE.AmbientLight(0xffffff,0.8); 
					scene.add(ambientLight);

					lights = new Array(numberOfLights);
				}

				// GUI per l'interazione di modifica dei materiali delle varie parti
				function buildNewGUI() {
					clearGUI();
					
					//
					selezioneParte1 = gui.addFolder('Parte 1');
					selezioneParte2 = gui.addFolder('Parte 2');
					selezioneParte3 = gui.addFolder('Parte 3');
					selezioneParte4 = gui.addFolder('Parte 4');
					selezioneParte5 = gui.addFolder('Parte 5');

					selezioneParte1.add(parametriSelezioneModello.parte1,'materialeSelezionato',[ "Oro", "Alluminio","Plastica lucida", "Plastica opaca" ]).onChange(
					function( value ) {
						console.log("Hey!, changed material on Part1");
						updateMaterialType(1);
						if(parametriSelezioneModello.parte1.materialeSelezionato == "Oro" || parametriSelezioneModello.parte1.materialeSelezionato =="Alluminio"){
							colorPicker1.domElement.hidden = true;		
						}else{
							colorPicker1.domElement.hidden = false;
						}
					});
			
					colorPicker1 = selezioneParte1.addColor(parametriSelezioneModello.parte1,'coloreSelezionato').onChange(
						function(value){
						console.log("Hey! color changed on Part1");
						updateMaterialType(1);	
					});

					selezioneParte2.add(parametriSelezioneModello.parte2,'materialeSelezionato',[ "Plastica lucida", "Plastica opaca", ]).onChange(
					function( value ) {
						console.log("Hey!, changed material  on Part2");
						updateMaterialType(2);
					});
			
					colorPicker2 = selezioneParte2.addColor(parametriSelezioneModello.parte2,'coloreSelezionato').onChange(
						function(value){
						console.log("Hey! color changed on Part2");
						updateMaterialType(2);	
					});

					selezioneParte3.add(parametriSelezioneModello.parte3,'materialeSelezionato',[ "Plastica lucida", "Plastica opaca", ]).onChange(
					function( value ) {
						console.log("Hey!, changed material on Part3");
						updateMaterialType(3);
					});
			
					colorPicker3 = selezioneParte3.addColor(parametriSelezioneModello.parte3,'coloreSelezionato').onChange(
						function(value){
						console.log("Hey! color changed on Part3");
						updateMaterialType(3);	
					});

					selezioneParte4.add(parametriSelezioneModello.parte4,'materialeSelezionato',[ "Plastica lucida", "Plastica opaca", ]).onChange(
					function( value ) {
						console.log("Hey!, changed material on Part4");
						updateMaterialType(4);
					});
			
					colorPicker4 = selezioneParte4.addColor(parametriSelezioneModello.parte4,'coloreSelezionato').onChange(
						function(value){
						console.log("Hey! color changed on Part4");
						updateMaterialType(4);	
					});

					selezioneParte5.add(parametriSelezioneModello.parte5,'materialeSelezionato',[ "Plastica lucida", "Plastica opaca", ]).onChange(
					function( value ) {
						console.log("Hey!, changed material on Part5");
						updateMaterialType(5);
					});
			
					colorPicker5 = selezioneParte5.addColor(parametriSelezioneModello.parte5,'coloreSelezionato').onChange(
						function(value){
						console.log("Hey! color changed on Part5");
						updateMaterialType(5);	
					});
				}

				function clearGUI() {
					if ( gui ) gui.destroy();
					gui = new dat.GUI();
					gui.open();
				}
	
				function spawnFloor(larghezza,altezza,profondità,pos_y){
					var geometry1 = new THREE.CubeGeometry(larghezza,altezza,profondità);
					var material1 = new THREE.MeshPhongMaterial( { color:"white" } );
					var floor = new THREE.Mesh( geometry1, material1 );
					floor.receiveShadow = true;
					scene.add(floor);
					floor.position.y = pos_y;
				}
				// ___________________________________________________________________________________________________________________________________________________________________________
				// Main code goes here:
	
				Start();
				Update();
				
			</script>
		</body>
	</html>